#!/usr/bin/env bash

# Resolve symlinks to find the actual script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done

SET_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
BASE_DIR="$(dirname "$SET_DIR")"

# Color codes for formatted output
C_RST='\033[0m'      # Reset
C_B='\033[1m'        # Bold
C_G='\033[0;32m'     # Green
C_C='\033[0;36m'     # Cyan

# --- LOGGING CONFIGURATION ---
CONFIG_FILE="${BASE_DIR}/config/toolkit.conf"
if [[ -f "$CONFIG_FILE" ]]; then
    source "$CONFIG_FILE"
fi

# Set defaults
LOG_DIR="${LOG_DIR:-${BASE_DIR}/logs}"
LOG_FILE="${LOG_FILE:-${LOG_DIR}/toolkit.log}"
LOG_LEVEL="${LOG_LEVEL:-INFO}"
LOG_RETENTION_DAYS="${LOG_RETENTION_DAYS:-7}"
LOG_ENABLED_MODULES="${LOG_ENABLED_MODULES:-all}"

# Ensure log directory exists
if [[ ! -d "$LOG_DIR" ]]; then
    mkdir -p "$LOG_DIR"
fi

# Logging function
_lsm_log() {
    local level="$1"
    local message="$2"
    local module="${MODULE:-core}"

    # Check if logging is enabled for this module
    if [[ "$LOG_ENABLED_MODULES" != "all" && "$LOG_ENABLED_MODULES" != *"$module"* ]]; then
        return
    fi

    # Check log level priority
    local level_priority
    local config_priority
    
    case "$level" in
        ERROR) level_priority=1 ;;
        WARN)  level_priority=2 ;;
        INFO)  level_priority=3 ;;
        DEBUG) level_priority=4 ;;
        *)     level_priority=3 ;;
    esac

    case "$LOG_LEVEL" in
        ERROR) config_priority=1 ;;
        WARN)  config_priority=2 ;;
        INFO)  config_priority=3 ;;
        DEBUG) config_priority=4 ;;
        *)     config_priority=3 ;;
    esac

    if [[ $level_priority -gt $config_priority ]]; then
        return
    fi

    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    echo "[$timestamp] [$level] [$module] $message" >> "$LOG_FILE"
}

# Log rotation
_lsm_rotate_logs() {
    [[ ! -d "$LOG_DIR" ]] && return

    # Archive current log if it's from a previous day
    if [[ -f "$LOG_FILE" ]]; then
        local log_date
        log_date=$(date -r "$LOG_FILE" "+%Y-%m-%d" 2>/dev/null)
        local current_date=$(date "+%Y-%m-%d")
        
        if [[ -n "$log_date" && "$log_date" != "$current_date" ]]; then
            local archive_file="${LOG_FILE}.${log_date}"
            mv "$LOG_FILE" "$archive_file"
            if command -v gzip >/dev/null 2>&1; then
                gzip "$archive_file"
            fi
        fi
    fi

    # Delete logs older than retention days
    local log_filename=$(basename "$LOG_FILE")
    find "$LOG_DIR" -name "${log_filename}.*" -type f -mtime +"$LOG_RETENTION_DAYS" -delete 2>/dev/null
}

# Perform log rotation on startup
_lsm_rotate_logs

# --- END LOGGING CONFIGURATION ---

# Discover available modules by scanning modules/ directory
_lsm_discover_modules() {
    local modules_dir="${BASE_DIR}/modules"
    for module_file in "${modules_dir}"/*.sh; do
        [[ -f "$module_file" ]] || continue
        basename "$module_file" .sh
    done
}

# Extract metadata from module file header
# Usage: _lsm_extract_metadata <module_name> <field>
# Fields: Description, Commands
_lsm_extract_metadata() {
    local module="$1"
    local field="$2"
    local file="${BASE_DIR}/modules/${module}.sh"
    [[ ! -f "$file" ]] && return 1
    grep -m1 "^# ${field}:" "$file" 2>/dev/null | sed "s/^# ${field}:[[:space:]]*//"
}

# Display main help message
_lsm_show_help() {
    echo -e "${C_B}${C_C}Linux System Management Toolkit${C_RST}"
    echo -e "${C_C}================================${C_RST}"
    echo ""
    echo -e "${C_B}Usage:${C_RST}"
    echo "  lsm <module> <command> [options]"
    echo "  lsm --help | -h | help"
    echo "  lsm <module> --help"
    echo ""
    echo -e "${C_B}Available Modules:${C_RST}"

    local module desc cmds
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue
        desc=$(_lsm_extract_metadata "$module" "Description")
        cmds=$(_lsm_extract_metadata "$module" "Commands")

        echo -e "  ${C_G}${module}${C_RST}"
        if [[ -n "$desc" ]]; then
            echo "    Description: $desc"
        fi
        if [[ -n "$cmds" ]]; then
            echo "    Commands: $cmds"
        fi
        echo ""
    done < <(_lsm_discover_modules)

    echo -e "${C_B}Examples:${C_RST}"
    echo "  lsm system memory     # Display memory usage"
    echo "  lsm disk list         # List all disks"
    echo "  lsm disk --help       # Show disk module help"
    echo ""
    echo -e "${C_B}Options:${C_RST}"
    echo "  -h, --help            Show this help message"
    echo "  <module> --help       Show module-specific help"
}

# Handle global help flags first
case "${1:-}" in
    -h|--help|help)
        _lsm_show_help
        exit 0
        ;;
esac

MODULE="${1:-}"
COMMAND="${2:-}"

if [[ -z "$MODULE" || -z "$COMMAND" ]]; then
    echo "Usage: $0 <module> <command> [args...]"
    exit 1
fi
# Show global help if no module provided
if [[ -z "$MODULE" ]]; then
    _lsm_show_help
    exit 0
fi

MODULE_PATH="${BASE_DIR}/modules/${MODULE}.sh"

# Handle module-level help: lsm <module> --help, lsm <module> -h, or lsm <module>
if [[ "$COMMAND" == "--help" || "$COMMAND" == "-h" || -z "$COMMAND" ]]; then
    if [[ -f "$MODULE_PATH" ]]; then
        source "$MODULE_PATH"
        if declare -f "${MODULE}_help" > /dev/null; then
            "${MODULE}_help"
            exit 0
        else
            echo "Error: Module '$MODULE' does not have a help function"
            exit 1
        fi
    else
        echo "Error: Module '$MODULE' not found"
        exit 1
    fi
fi

if [[ -f "$MODULE_PATH" ]]; then
    source "$MODULE_PATH"
    # Call the function: <module>_<command> with any remaining arguments
    # Shift past module and command to get remaining args
    shift 2
    if declare -f "${MODULE}_${COMMAND}" > /dev/null; then
        "${MODULE}_${COMMAND}" "$@"
    else
        _lsm_log "ERROR" "Command '$COMMAND' not found in module '$MODULE'"
        echo "Error: Command '$COMMAND' not found in module '$MODULE'"
        exit 1
    fi
else
    _lsm_log "ERROR" "Module '$MODULE' not found at $MODULE_PATH"
    echo "Error: Module '$MODULE' not found at $MODULE_PATH"
    exit 1
fi
