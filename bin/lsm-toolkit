#!/usr/bin/env bash

# Resolve symlinks to find the actual script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done

SET_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
BASE_DIR="$(dirname "$SET_DIR")"

# Color codes for formatted output
C_RST='\033[0m'      # Reset
C_B='\033[1m'        # Bold
C_G='\033[0;32m'     # Green
C_C='\033[0;36m'     # Cyan

# Discover available modules by scanning modules/ directory
_lsm_discover_modules() {
    local modules_dir="${BASE_DIR}/modules"
    for module_file in "${modules_dir}"/*.sh; do
        [[ -f "$module_file" ]] || continue
        basename "$module_file" .sh
    done
}

# Extract metadata from module file header
# Usage: _lsm_extract_metadata <module_name> <field>
# Fields: Description, Commands
_lsm_extract_metadata() {
    local module="$1"
    local field="$2"
    local file="${BASE_DIR}/modules/${module}.sh"
    [[ ! -f "$file" ]] && return 1
    grep -m1 "^# ${field}:" "$file" 2>/dev/null | sed "s/^# ${field}:[[:space:]]*//"
}

# Interactive Menu System
_lsm_interactive_menu() {
    local options=()
    local modules=()
    local i=1

    echo -e "${C_B}${C_C}Welcome to the Linux System Management Toolkit (LSM)${C_RST}"
    echo "------------------------------------------------"

    # Populate module list
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue
        modules+=("$module")
        local desc=$(_lsm_extract_metadata "$module" "Description")
        options+=("$i) $module - ${desc:-No description}")
        ((i++))
    done < <(_lsm_discover_modules)

    if [[ ${#modules[@]} -eq 0 ]]; then
        echo "No modules found in modules/"
        exit 1
    fi

    echo "Please select a module to manage:"
    for opt in "${options[@]}"; do
        echo "  $opt"
    done
    echo "  q) Quit"
    echo ""

    local selection
    read -p "Enter your choice [1-${#modules[@]} or q]: " selection

    if [[ "$selection" == "q" ]]; then
        echo "Goodbye!"
        exit 0
    fi

    if [[ ! "$selection" =~ ^[0-9]+$ ]] || (( selection < 1 || selection > ${#modules[@]} )); then
        echo "Invalid selection."
        exit 1
    fi

    local selected_module="${modules[$((selection-1))]}"
    _lsm_module_menu "$selected_module"
}

# Sub-menu for a specific module
_lsm_module_menu() {
    local module="$1"
    local module_path="${BASE_DIR}/modules/${module}.sh"

    if [[ ! -f "$module_path" ]]; then
        echo "Error: Module file not found."
        exit 1
    fi

    # Source the module to get its functions
    source "$module_path"

    echo ""
    echo -e "${C_B}Module: ${C_G}${module}${C_RST}"
    echo "Available commands:"

    # We need to find commands. A simple convention or reading "Commands" metadata is good.
    # But for a robust menu, we might iterate over functions starting with "${module}_"
    # However, parsing metadata is safer if we want to show descriptions.
    # For now, let's use the regex approach to find exported functions to list them dynamically
    # OR we can just rely on the user knowing what commands or the "Commands" metadata line if it's strict.
    
    # Let's try to extract commands from the metadata first as it is user-friendly
    local cmds_meta=$(_lsm_extract_metadata "$module" "Commands")
    
    # Just list them from the metadata string for display
    echo "  $cmds_meta"
    
    echo ""
    read -p "Enter command to run (or 'b' to back, 'q' to quit): " cmd_selection

    if [[ "$cmd_selection" == "q" ]]; then
         exit 0
    elif [[ "$cmd_selection" == "b" ]]; then
         _lsm_interactive_menu
         return
    fi
    
    # Execute
    echo ""
    $0 "$module" "$cmd_selection"
    
    echo ""
    read -p "Press Enter to continue..."
    _lsm_interactive_menu
}

# Display main help message
_lsm_show_help() {
    echo -e "${C_B}${C_C}Linux System Management Toolkit${C_RST}"
    echo -e "${C_C}================================${C_RST}"
    echo ""
    echo -e "${C_B}Usage:${C_RST}"
    echo "  lsm                                     # Launch interactive menu"
    echo "  lsm <module> <command> [options]        # Run specific command"
    echo "  lsm --help | -h | help                  # Show this help"
    echo "  lsm <module> --help                     # Show module-specific help"
    echo ""
    echo -e "${C_B}Available Modules:${C_RST}"

    local module desc cmds
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue
        desc=$(_lsm_extract_metadata "$module" "Description")
        cmds=$(_lsm_extract_metadata "$module" "Commands")

        echo -e "  ${C_G}${module}${C_RST}"
        if [[ -n "$desc" ]]; then
            echo "    Description: $desc"
        fi
        if [[ -n "$cmds" ]]; then
            echo "    Commands: $cmds"
        fi
        echo ""
    done < <(_lsm_discover_modules)

    echo -e "${C_B}Examples:${C_RST}"
    echo "  lsm                   # Start interactive mode"
    echo "  lsm system memory     # Display memory usage"
    echo "  lsm disk list         # List all disks"
    echo "  lsm disk --help       # Show disk module help"
    echo ""
    echo -e "${C_B}Options:${C_RST}"
    echo "  -h, --help            Show this help message"
    echo "  <module> --help       Show module-specific help"
}

# Handle global help flags first
case "${1:-}" in
    -h|--help|help)
        _lsm_show_help
        exit 0
        ;;
esac

# Interactive mode if no arguments
if [[ -z "$1" ]]; then
    _lsm_interactive_menu
    exit 0
fi

MODULE="${1:-}"
COMMAND="${2:-}"
shift 2  # Remove first two arguments, leaving only additional args

if [[ -z "$MODULE" ]]; then
    _lsm_show_help
    exit 0
fi

MODULE_PATH="${BASE_DIR}/modules/${MODULE}.sh"

# Handle module-level help: lsm <module> --help, lsm <module> -h, or lsm <module>
if [[ "$COMMAND" == "--help" || "$COMMAND" == "-h" || -z "$COMMAND" ]]; then
    if [[ -f "$MODULE_PATH" ]]; then
        source "$MODULE_PATH"
        if declare -f "${MODULE}_help" > /dev/null; then
            "${MODULE}_help"
            exit 0
        else
            echo "Error: Module '$MODULE' does not have a help function"
            exit 1
        fi
    else
        echo "Error: Module '$MODULE' not found"
        exit 1
    fi
fi

if [[ -f "$MODULE_PATH" ]]; then
    source "$MODULE_PATH"
    # Call the function: <module>_<command>
    if declare -f "${MODULE}_${COMMAND}" > /dev/null; then
        "${MODULE}_${COMMAND}" "$@"
    else
        echo "Error: Command '$COMMAND' not found in module '$MODULE'"
        exit 1
    fi
else
    echo "Error: Module '$MODULE' not found at $MODULE_PATH"
    exit 1
fi
